xorq %rcx,%rcx

A : %rcx 레지스터 값을 0으로 바꾼다.
B : movq $0, %rcx나 andq $0, %rcx 같은 것도 같은 효과를 낼 수 있다.
C : 
xor의 경우 명령어 바이트 길이가 2 바이트로 짧고 조건 코드(CF, ZF, SF)가 변경된다. 의존성이 없는 명령어로
%rax의 값을 확인도 하지 않고 바로 0으로 초기화한다. 프로세서 내부적으로 최적화하여 효율적으로 실행한다.
mov의 경우 명령어 바이트 길이는 7 바이트로 길어 실행 속도가 xor에 비해 느리다. immediate value를 바로
저장하므로 and 연산보다는 효율적이다. 조건 코드는 변경되지 않는다.
and의 경우 바이트 길이는 4 바이트로 명령어 길이가 길다. immediate value 0과 레지스터 값을 참조하여 계산
해야 되기 때문에 불필요한 계산이 발생한다. 또 기존 %rcx 값을 읽고 나서 연산을 수행하므로 CPU 내부적으로 불필
요한 의존성이 생긴다. 
