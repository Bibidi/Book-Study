The following is the actual assembly code generated by gcc for function fix_
prod_ele. We see that four registers are used as follows: %eax holds result, %rdi
holds Aptr, %rcx holds Bptr, and %rsi holds Bend.

int fix_prod_ele_opt(fix_matrix A, fix_matrix B, long i, long k)
A in %rdi, B in %rsi, i in %rdx, k in %rcx
1 fix_prod_ele:
2 salq $6, %rdx Compute 64 * i
3 addq %rdx, %rdi Compute Aptr = xA + 64i = &A[i][0]
4 leaq (%rsi,%rcx,4), %rcx Compute Bptr = xB + 4k = &B[0][k]
5 leaq 1024(%rcx), %rsi Compute Bend = xB + 4k + 1024 = &B[N][k]
6 movl $0, %eax Set result = 0
7 .L7: loop:
8 movl (%rdi), %edx Read *Aptr
9 imull (%rcx), %edx Multiply by *Bptr
10 addl %edx, %eax Add to result
11 addq $4, %rdi Increment Aptr ++
12 addq $64, %rcx Increment Bptr += N
13 cmpq %rsi, %rcx Compare Bptr:Bend
14 jne .L7 If !=, goto loop
15 rep; ret Return

Use Equation 3.1 to explain how the computations of the initial values for Aptr,
Bptr, and Bend in the C code of Figure 3.37(b) (lines 3â€“5) correctly describe their
computations in the assembly code generated for fix_prod_ele

Answer:
Aptr = x_A + L * (C * i + 0) = x_A + 64 * i       => C = 16
Bptr = x_B + L * (C * 0 + k) = x_B + 4k           => L = 4
Bend = x_B + L * (C * N + k) = x_B + 4k + 1024    => N = 16